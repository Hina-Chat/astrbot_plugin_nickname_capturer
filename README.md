# ⚠️ 專案封存：一次光榮的失敗 (2025-07-06)

**結論先行：本專案所追求的核心目標——在 QQ 官方 Webhook 模式下，可靠地獲取並注入使用者的群組暱稱——經最終證實，是無法實現的。**

我們在此宣告本外掛的探索已達終點。這不是一次程式碼的失敗，而是一次對平台能力邊界的成功探勘。我們以最嚴謹的方式，證明了這條路無法走通。

### 失敗的根源：源頭無水

我們最後的、也是最深入的調查，將我們引向了 `botpy` 的核心原始碼和對 QQ 官方 API 行為的最終推斷。真相是殘酷且清晰的：

> **QQ 官方的 Webhook 事件，在推送「群組聊天訊息」時，其資料包內的 `author` 物件，有且僅有使用者的 `member_openid`，完全不包含使用者的群組暱稱（`nick`）欄位。**

資料，在源頭就不存在。這意味著，任何下游的努力，無論是解析內容、修補框架，都只是在建造空中樓閣。AstrBot 原始碼中將 `nickname` 硬編碼為空字串（`""`）的行為，也佐證了其開發者早已面對過這面無法逾越的高牆。

### 我們的探索之路：從幻覺到真相

為了抵達這個最終結論，我們歷經了數個階段的艱苦探索，每一步都充滿了血淚與教訓：

1.  **幻覺階段**：最初，我們天真地以為可以透過解析「回覆訊息」中的 `@` 內容來擷取暱稱。這被證明是一個致命的錯誤假設。
2.  **深入 AstrBot**：我們深入 AstrBot 原始碼，發現了暱稱被硬編碼為空字串的「犯罪現場」，從而將調查方向轉向了上游的 `botpy`。
3.  **剖析 botpy**：我們剖析了 `botpy` 的 `GroupMessage` 類別，最終確認了其 `author` 物件在設計上就只有 `member_openid`，沒有暱稱。
4.  **追獵官方文件**：我們發起了「幽靈協議」，試圖在 QQ 官方的開發者文件中找到那個被 `botpy` 忽略的「幽靈欄位」，但最終發現，官方對此諱莫如深，甚至沒有提供一份清晰的 Webhook Payload 文件。

---

雖然本專案以功能上的「失敗」告終，但其探索過程本身，以及下方保留的原始 `README` 和「技術經驗」，為我們留下了關於猴子補丁（Monkey Patching）、框架資料流、以及如何進行系統性問題排查的寶貴財富。

謹以此文件，紀念我們這段嚴謹、執著、雖敗猶榮的旅程。

---

*（原始 README 內容如下）*

# AstrBot QQ 暱稱擷取器外掛

## 概述

`Nickname Capturer` 是一個為 [AstrBot](https://github.com/HinaKage/AstrBot) 設計的、非侵入式的 QQ 群組聊天暱稱擷取與注入外掛。它旨在解決 QQ 官方 Webhook 平台下，機器人無法直接獲知使用者群組暱稱的問題，從而實現更具個人化和沉浸感的互動體驗。

## 背景問題

在預設的 AstrBot 工作流程中，透過 QQ 官方 Webhook 接收到的群組聊天訊息，事件物件中的 `sender` 資訊只包含使用者的 OpenID，而缺少使用者在該群組的群名片（暱稱）。這使得機器人在回應時，無法親切地稱呼使用者，也讓其他需要使用者暱稱的外掛（如日誌、記憶系統）無法正常工作。

## 核心功能

- **智慧擷取**：僅當使用者透過「回覆」機器人的訊息進行互動時，外掛會自動從原始資料包中提取其目前的群組暱稱。
- **無感注入**：一旦成功擷取某使用者的暱稱，該使用者後續傳送的**任何**訊息（包括普通聊天和指令），其暱稱都會被自動、無感地注入到事件物件中。
- **動態更新**：如果使用者在群組內修改了暱稱，只需再次回覆一次機器人，外掛即可自動更新快取，確保後續所有互動都使用最新的暱稱。
- **非侵入式設計**：完全透過猴子補丁（Monkey Patching）實現，無需修改 AstrBot 或 `botpy` 的任何核心原始碼，保證了框架的純淨和升級的平滑。
- **高強健性**：具備完善的生命週期管理，在外掛載入時應用補丁，卸載時完美恢復，確保了系統的穩定。
- **詳盡日誌**：提供了清晰的 `INFO` 和 `DEBUG` 級別日誌，完整記錄了從資料攔截到暱稱注入的全過程，便於除錯和理解工作流程。

## 工作原理

本外掛的實現凝聚了對 AstrBot 核心機制的深度理解，其工作流程如同一場精妙的外科手術：

1.  **攔截入口 (`__init__` Patch)**：在外掛初始化時，我們對 `QQOfficialWebhook` 類別的 `__init__` 方法進行猴子補丁。這使得我們能在 AstrBot 的 Web 服務（Quart）註冊回呼路由之前，用我們自己的、增強版的回呼函式替換掉原始的回呼函式。

2.  **原始資料暫存**：增強版的回呼函式在呼叫原始解析邏輯前，會將收到的原始 Webhook JSON 資料，以訊息 ID 為鍵，暫存到一個全域的、執行緒安全的字典 `_temp_raw_data_map` 中。

3.  **解析時注入 (`_parse_from_qqofficial` Patch)**：接著，我們對 `QQOfficialPlatformAdapter` 的 `_parse_from_qqofficial` 靜態方法打上補丁。在其解析 `botpy` 訊息物件並建立 `AstrBotMessage` 的過程中，我們根據訊息 ID 從暫存區取出原始資料，並將其作為一個新的屬性 `raw_qq_webhook_d` 附加到 `AstrBotMessage` 物件上。

4.  **兩階段事件處理**：這是外掛的核心業務邏輯，在一個高優先權的 `on_event` 處理器中實現：
    - **第一階段：快取注入**：對於**任何**接收到的群組聊天訊息，處理器首先檢查該使用者的 ID 是否存在於暱稱快取中。如果存在，則**立即**將快取的暱稱注入到目前事件物件的 `event.message_obj.sender.nickname` 屬性中。
    - **第二階段：提取與更新**：在注入完成後，處理器會檢查訊息的原始資料中是否包含 `parallel_message` 欄位（即判斷是否為回覆訊息）。**僅當**是回覆訊息時，它才會繼續執行暱稱提取邏輯，從回覆內容中透過正規表示式比對到 `@暱稱`，然後用這個新擷取的暱稱，再次更新目前事件物件，並刷新快取。

透過這個精巧的流程，外掛實現了「一次回覆，永久識別」的智慧效果，並確保了所有訊息類型都能享受到暱稱注入帶來的便利。

## 安裝與使用

1.  將 `astrbot_plugin_nickname_capturer` 整個資料夾放置於 AstrBot 的 `plugins` 目錄下。
2.  重新啟動 AstrBot，外掛將自動載入並開始工作。
3.  **觸發擷取**：為了讓機器人記住或更新你的暱稱，你需要在群組裡**回覆**任意一條機器人的訊息。完成一次成功的回覆後，外掛便會記錄下你的暱稱。
4.  **享受互動**：在那之後，你傳送的所有普通訊息，機器人（以及其他外掛）都將能正確識別你的名字。

---

<details>
<summary><strong>我們的技術經驗：從失敗到成功的血淚史</strong></summary>

這段看似簡單的外掛開發旅程，實際上是一部充滿陷阱、彎路和頓悟的探索史。這裡記錄了我們遇到的每一個關鍵挑戰以及最終的解決方案，希望能為未來的開發者提供寶貴的借鏡。

1.  **陷阱一：實例方法與類別方法的補丁之差**
    - **最初的失敗**：我們一開始嘗試直接修補 `QQOfficialWebhook.callback` 這個類別方法。但無論如何都不生效。深入原始碼後發現，`callback` 方法是在 `QQOfficialWebhook` 的 `__init__` 建構函式中，被註冊到 Quart Web 實例上的。這意味著，當我們的外掛載入時，`QQOfficialWebhook` 的實例早已建立，路由已經綁定到了**原始的實例方法**上。我們對類別方法的修改，對那個已經存在的實例毫無影響。
    - **頓悟與正解**：唯一的辦法，是在實例建立之初就介入。因此，我們最終選擇了修補 `__init__` 方法本身。透過在這個建構方法內部替換掉傳遞给路由的回呼函式，我們成功地「偷天換日」，在不破壞原始物件結構的前提下，完全控制了回呼邏輯。

2.  **陷阱二：跨越鴻溝的資料流**
    - **問題**：我們成功在回呼函式中攔截了原始資料，但下一個難題是：如何將這些資料，安全、準確地傳遞給處於外掛處理鏈末端的 `on_event` 事件處理器？兩者之間隔著遙遠的 AstrBot 核心解析流程。
    - **解決方案**：我們設計了一個「兩步走」的補丁策略。第一步，在回呼函式中，將原始資料以全域唯一的 `message.id` 為鍵，存入一個臨時的全域字典。第二步，在核心解析方法 `_parse_from_qqofficial` 中再次植入程式碼，它負責根據正在處理的 `message.id`，從全域字典中取出資料，並將其「塞」進最終產生的 `AstrBotMessage` 物件的一個新屬性裡。這個方法雖然曲折，但卻像一條可靠的地下管道，完美地解決了資料跨層級傳遞的難題。

3.  **陷阱三：`.name` vs `.nickname` 的致命細節**
    - **最痛苦的疏忽**：在解決了所有資料流問題，並且邏輯看似完美之後，我們發現最終的日誌中，暱稱欄位依然為空。在經歷了漫長的程式碼審查和邏輯推演後，我們幾乎陷入絕望。最終，在用戶的堅持下，我們直接搜尋了產生那行日誌的**核心函式庫原始碼**。
    - **真相**：原始碼 `astrbot_message.py` 中的 `MessageMember.__str__` 方法赫然寫著，它印出的是 `self.nickname` 屬性。而我們嘔心瀝血編寫的外掛，一直在修改的是 `self.name`！一個字母之差，讓我們所有的努力都化為泡影。這個教訓是慘痛的：**永遠不要相信你的假設，去讀原始碼，原始碼是唯一的真相。**

4.  **陷阱四：單一職責到複合職責的架構演進**
    - **最初的設計缺陷**：外掛最初的邏輯是：「如果是回覆，就提取並注入暱稱」。這導致了一個尷尬的局面：只有回覆訊息才能被正確處理，而普通聊天訊息則被完全忽略，即便我們已經快取了使用者的暱稱。
    - **架構的昇華**：在用戶的敏銳洞察下，我們將外掛的職責一分為二，重構了整個事件處理器。第一步，是**無條件的快取注入**，確保所有已知使用者的訊息都能被處理。第二步，是**有條件的提取更新**，僅在回覆訊息中觸發學習機制。這次重構，讓外掛的行為從「被動響應」演進為「主動服務」，在邏輯上達到了真正的強健與完備。

這段經歷告訴我們，優秀的軟體工程，不僅在於精巧的編碼，更在於面對失敗時，敢於推翻一切、深入源頭、並不斷演進架構的嚴謹與勇氣。

</details>
